# Задание 1:
#
# Контекст:
# Предположим, что мы хотим найти элемент в массиве (получить
# его индекс). Мы можем это сделать просто перебрав все элементы.
# Но что, если массив уже отсортирован? В этом случае можно
# использовать бинарный поиск. Принцип прост: сначала берём
# элемент находящийся посередине и сравниваем с тем, который мы
# хотим найти. Если центральный элемент больше нашего,
# рассматриваем массив слева от центрального, а если больше -
# справа и повторяем так до тех пор, пока не найдем наш элемент.
#
# Ваша задача:
# Написать программу на любом языке в любой парадигме для
# бинарного поиска. На вход подаётся целочисленный массив и
# число. На выходе - индекс элемента или -1, в случае если искомого
# элемента нет в массиве.


def binary_search(lst: list[int], num: int):
    if len(lst) > 1:
        index = len(lst) // 2
        print(f"Ищем число {num}, проверяем список {lst}, индекс {index}, по этому индексу находится число {lst[index]}")
        if lst[index] < num:
            return binary_search(lst[index:], num)
        elif lst[index] > num:
            return binary_search(lst[:index], num)
        else:
            return f"Число {num} есть в списке"
    else:
        return f'Числа {num} нет в списке'


nums = [1, 6, 8, 15, 17, 18, 34, 46, 125, 344, 568, 999]
print(binary_search(nums, 18))
print(binary_search(nums, 1000))
